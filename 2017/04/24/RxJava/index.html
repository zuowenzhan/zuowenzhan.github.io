<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="学习来源 对于Android开发人员而言，Rxjava并不陌生，最流行的Android三剑客（MVP+Retrofit+RxJava）不得不学习，最近开始整理关于三剑客的一些学习笔记，一方面作为巩固，另一方面希望能帮助到初学者。 GitHub 链接： https://github.com/ReactiveX/RxJava  https://github.com/ReactiveX/RxAndroi">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava">
<meta property="og:url" content="http://yoursite.com/2017/04/24/RxJava/index.html">
<meta property="og:site_name" content="Android进阶之路--左文站">
<meta property="og:description" content="学习来源 对于Android开发人员而言，Rxjava并不陌生，最流行的Android三剑客（MVP+Retrofit+RxJava）不得不学习，最近开始整理关于三剑客的一些学习笔记，一方面作为巩固，另一方面希望能帮助到初学者。 GitHub 链接： https://github.com/ReactiveX/RxJava  https://github.com/ReactiveX/RxAndroi">
<meta property="og:updated_time" content="2017-05-11T02:35:48.967Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava">
<meta name="twitter:description" content="学习来源 对于Android开发人员而言，Rxjava并不陌生，最流行的Android三剑客（MVP+Retrofit+RxJava）不得不学习，最近开始整理关于三剑客的一些学习笔记，一方面作为巩固，另一方面希望能帮助到初学者。 GitHub 链接： https://github.com/ReactiveX/RxJava  https://github.com/ReactiveX/RxAndroi">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/24/RxJava/"/>





  <title>RxJava | Android进阶之路--左文站</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Android进阶之路--左文站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            GitHub集锦
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            作者简介
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/RxJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="左文站">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android进阶之路--左文站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RxJava</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T16:16:59+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/04/24/RxJava/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/04/24/RxJava/" class="leancloud_visitors" data-flag-title="RxJava">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">学习来源</a></p>
<p>对于Android开发人员而言，Rxjava并不陌生，最流行的Android三剑客（MVP+Retrofit+RxJava）不得不学习，最近开始整理关于三剑客的一些学习笔记，一方面作为巩固，另一方面希望能帮助到初学者。</p>
<p>GitHub 链接：</p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a> </p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">https://github.com/ReactiveX/RxAndroid</a></p>
<pre><code>引入依赖：

compile &apos;io.reactivex:rxjava:1.0.14&apos;

compile &apos;io.reactivex:rxandroid:1.0.1&apos;
</code></pre><a id="more"></a>
<h4 id="RxJava-到底是什么"><a href="#RxJava-到底是什么" class="headerlink" title="RxJava 到底是什么"></a>RxJava 到底是什么</h4><p>一个词：异步。</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。<br>其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p>
<h4 id="RxJava-好在哪"><a href="#RxJava-好在哪" class="headerlink" title="RxJava 好在哪"></a>RxJava 好在哪</h4><p>一个词：简洁。</p>
<p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』<br>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p> 假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</p>
<pre><code>new Thread() {
@Override
public void run() {
    super.run();
    for (File folder : folders) {
        File[] files = folder.listFiles();
        for (File file : files) {
            if (file.getName().endsWith(&quot;.png&quot;)) {
                final Bitmap bitmap = getBitmapFromFile(file);
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        imageCollectorView.addImage(bitmap);
                    }
                });
            }
        }
    }
}
}.start();
</code></pre><p>而如果使用 RxJava ，实现方式是这样的：</p>
<pre><code>Observable.from(folders)
.flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() {
    @Override
    public Observable&lt;File&gt; call(File file) {
        return Observable.from(file.listFiles());
    }
})
.filter(new Func1&lt;File, Boolean&gt;() {
    @Override
    public Boolean call(File file) {
        return file.getName().endsWith(&quot;.png&quot;);
    }
})
.map(new Func1&lt;File, Bitmap&gt;() {
    @Override
    public Bitmap call(File file) {
        return getBitmapFromFile(file);
    }
})
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Action1&lt;Bitmap&gt;() {
    @Override
    public void call(Bitmap bitmap) {
        imageCollectorView.addImage(bitmap);
    }
});
</code></pre><h3 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h3><p>RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。</p>
<p>onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。<br>onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。<br>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>基于以上的概念， RxJava 的基本实现主要有三点：</p>
<h4 id="创建-Observer"><a href="#创建-Observer" class="headerlink" title="创建 Observer"></a>创建 Observer</h4><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
@Override
public void onNext(String s) {
    Log.d(tag, &quot;Item: &quot; + s);
}

@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}

@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}
};
</code></pre><p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<pre><code>Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
@Override
public void onNext(String s) {
    Log.d(tag, &quot;Item: &quot; + s);
}

@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}

@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}
};
</code></pre><p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<p>onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。<br>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>
<h4 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h4><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<pre><code>Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
@Override
public void call(Subscriber&lt;? super String&gt; subscriber) {
    subscriber.onNext(&quot;Hello&quot;);
    subscriber.onNext(&quot;Hi&quot;);
    subscriber.onNext(&quot;Aloha&quot;);
    subscriber.onCompleted();
}
});
</code></pre><p>可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<p>这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。</p>
<p>create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p>
<pre><code>  just(T...): 将传入的参数依次发送出来。
  Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
 // 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。
String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
 // onNext(&quot;Aloha&quot;);
 // onCompleted();
</code></pre><p>上面 just(T…) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。</p>
<h4 id="Subscribe-订阅"><a href="#Subscribe-订阅" class="headerlink" title="Subscribe (订阅)"></a>Subscribe (订阅)</h4><p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<p>observable.subscribe(observer);<br>// 或者：<br>observable.subscribe(subscriber);<br>有人可能会注意到， subscribe() 这个方法有点怪：它看起来是『observalbe 订阅了 observer / subscriber』而不是『observer / subscriber 订阅了 observalbe』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 observer.subscribe(observable) / subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p>
<pre><code>Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：

// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public Subscription subscribe(Subscriber subscriber) {
subscriber.onStart();
onSubscribe.call(subscriber);
return subscriber;
}
</code></pre><p>可以看到，subscriber() 做了3件事：</p>
<p>调用 Subscriber.onStart() 。这个方法在前面已经介绍过，是一个可选的准备方法。<br>调用 Observable 中的 OnSubscribe.call(Subscriber) 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。<br>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe().</p>
<p>除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下：</p>
<pre><code>Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {
// onNext()
@Override
public void call(String s) {
    Log.d(tag, s);
}
};
Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {
// onError()
@Override
public void call(Throwable throwable) {
    // Error handling
}
};
Action0 onCompletedAction = new Action0() {
// onCompleted()
@Override
public void call() {
    Log.d(tag, &quot;completed&quot;);
}
};

// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()

 observable.subscribe(onNextAction);

// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()

observable.subscribe(onNextAction, onErrorAction);

// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 
onCompleted()

observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
</code></pre><p>简单解释一下这段代码中出现的 Action1 和 Action0。 Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>下面举两个例子：</p>
<h4 id="打印字符串数组"><a href="#打印字符串数组" class="headerlink" title="打印字符串数组"></a>打印字符串数组</h4><p>将字符串数组 names 中的所有字符串依次打印出来：</p>
<pre><code>String[] names = ...;
Observable.from(names)
.subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String name) {
        Log.d(tag, name);
    }
});`
</code></pre><h4 id="由-id-取得图片并显示"><a href="#由-id-取得图片并显示" class="headerlink" title="由 id 取得图片并显示"></a>由 id 取得图片并显示</h4><p>由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：</p>
<pre><code>int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
@Override
public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
    Drawable drawable = getTheme().getDrawable(drawableRes));
    subscriber.onNext(drawable);
    subscriber.onCompleted();
}
}).subscribe(new Observer&lt;Drawable&gt;() {
@Override
public void onNext(Drawable drawable) {
    imageView.setImageDrawable(drawable);
}

@Override
public void onCompleted() {
}

@Override
public void onError(Throwable e) {
    Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
}
});
</code></pre><p>正如上面两个例子这样，创建出 Observable 和 Subscriber ，再用 subscribe() 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。</p>
<h2 id="线程控制-——-Scheduler-一"><a href="#线程控制-——-Scheduler-一" class="headerlink" title="线程控制 —— Scheduler (一)"></a>线程控制 —— Scheduler (一)</h2><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
<h4 id="1-Scheduler-的-API-一"><a href="#1-Scheduler-的-API-一" class="headerlink" title="1) Scheduler 的 API (一)"></a>1) Scheduler 的 API (一)</h4><p>在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个</p>
<p>Scheduler ，它们已经适合大多数的使用场景：</p>
<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>
<p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>
<p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于</p>
<p> io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放</p>
<p>在 io() 中，可以避免创建不必要的线程。</p>
<p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。</p>
<p>这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。<br>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
<p>有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 <em> subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 </em> observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<p>文字叙述总归难理解，上代码：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer number) {
        Log.d(tag, &quot;number:&quot; + number);
    }
})
</code></pre><p>上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p>
<p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>
<pre><code>      int drawableRes = ...;
     ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
@Override
public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
    Drawable drawable = getTheme().getDrawable(drawableRes));
    subscriber.onNext(drawable);
    subscriber.onCompleted();
}
})
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Observer&lt;Drawable&gt;() {
@Override
public void onNext(Drawable drawable) {
    imageView.setImageDrawable(drawable);
}

@Override
public void onCompleted() {
}

@Override
public void onError(Throwable e) {
    Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
}
});`
</code></pre><p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
<h4 id="Scheduler-的原理-一"><a href="#Scheduler-的原理-一" class="headerlink" title="Scheduler 的原理 (一)"></a>Scheduler 的原理 (一)</h4><p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>
<p>好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。</p>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p>
<p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p>
<p>1) API</p>
<p>首先看一个 map() 的例子：</p>
<pre><code>`Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&lt;String, Bitmap&gt;() {
    @Override
    public Bitmap call(String filePath) { // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    }
})
.subscribe(new Action1&lt;Bitmap&gt;() {
    @Override
    public void call(Bitmap bitmap) { // 参数类型 Bitmap
        showBitmap(bitmap);
    }
});
</code></pre><p>这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p>
<h5 id="map-事件对象的直接变换，具体功能上面已经介绍过。它是-RxJava-最常用的变换。"><a href="#map-事件对象的直接变换，具体功能上面已经介绍过。它是-RxJava-最常用的变换。" class="headerlink" title="map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。"></a>map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。</h5><h5 id="flatMap-这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。-首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单："><a href="#flatMap-这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。-首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：" class="headerlink" title="flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单："></a>flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</h5><pre><code>Student[] students = ...;
Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
@Override
public void onNext(String name) {
    Log.d(tag, name);
}
...
};
Observable.from(students)
.map(new Func1&lt;Student, String&gt;() {
    @Override
    public String call(Student student) {
        return student.getName();
    }
})
.subscribe(subscriber);`
</code></pre><p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>
<pre><code>Student[] students = ...;
Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() {
@Override
public void onNext(Student student) {
    List&lt;Course&gt; courses = student.getCourses();
    for (int i = 0; i &lt; courses.size(); i++) {
        Course course = courses.get(i);
        Log.d(tag, course.getName());
    }
}
...
};
Observable.from(students)
.subscribe(subscriber);`
</code></pre><p>依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p>
<p>这个时候，就需要用 flatMap() 了：</p>
<pre><code>`Student[] students = ...;
Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {
@Override
public void onNext(Course course) {
    Log.d(tag, course.getName());
}
...
};
Observable.from(students)
.flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {
    @Override
    public Observable&lt;Course&gt; call(Student student) {
        return Observable.from(student.getCourses());
    }
})
.subscribe(subscriber);`
</code></pre><p>从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</p>
<p>扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>
<pre><code>`networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token
.flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() {
    @Override
    public Observable&lt;Messages&gt; call(String token) {
        // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表
        return networkClient.messages();
    }
})
.subscribe(new Action1&lt;Messages&gt;() {
    @Override
    public void call(Messages messages) {
        // 处理显示消息列表
        showMessages(messages);
    }
});`
</code></pre><p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>
<h5 id="throttleFirst-在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：-RxView-clickEvents-button-RxBinding-代码，后面的文章有解释-throttleFirst-500-TimeUnit-MILLISECONDS-设置防抖间隔为-500ms-subscribe-subscriber-妈妈再也不怕我的用户手抖点开两个重复的界面啦。"><a href="#throttleFirst-在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：-RxView-clickEvents-button-RxBinding-代码，后面的文章有解释-throttleFirst-500-TimeUnit-MILLISECONDS-设置防抖间隔为-500ms-subscribe-subscriber-妈妈再也不怕我的用户手抖点开两个重复的界面啦。" class="headerlink" title="throttleFirst(): 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。"></a>throttleFirst(): 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。</h5><h4 id="变换的原理：lift"><a href="#变换的原理：lift" class="headerlink" title="变换的原理：lift()"></a>变换的原理：lift()</h4><p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）：</p>
<p>// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</p>
<p>// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</p>
<pre><code>`public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) {
return Observable.create(new OnSubscribe&lt;R&gt;() {
    @Override
    public void call(Subscriber subscriber) {
        Subscriber newSubscriber = operator.call(subscriber);
        newSubscriber.onStart();
        onSubscribe.call(newSubscriber);
    }
}); 
}`
</code></pre><p>这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）——</p>
<p>subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。</p>
<h5 id="当含有-lift-时："><a href="#当含有-lift-时：" class="headerlink" title="当含有 lift() 时："></a>当含有 lift() 时：</h5><p>1.lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； </p>
<p>2.而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe；</p>
<p>3.当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； </p>
<p>4.而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 </p>
<p>这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。<br>精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<h5 id="举一个具体的-Operator-的实现。下面这是一个将事件中的-Integer-对象转换成-String-的例子，仅供参考："><a href="#举一个具体的-Operator-的实现。下面这是一个将事件中的-Integer-对象转换成-String-的例子，仅供参考：" class="headerlink" title="举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考："></a>举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</h5><pre><code>`observable.lift(new Observable.Operator&lt;String, Integer&gt;() {
@Override
public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) {
    // 将事件序列中的 Integer 对象转换为 String 对象
    return new Subscriber&lt;Integer&gt;() {
        @Override
        public void onNext(Integer integer) {
            subscriber.onNext(&quot;&quot; + integer);
        }

        @Override
        public void onCompleted() {
            subscriber.onCompleted();
        }

        @Override
        public void onError(Throwable e) {
            subscriber.onError(e);
        }
    };
}
});`
</code></pre><p>讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。</p>
<h4 id="compose-对-Observable-整体的变换"><a href="#compose-对-Observable-整体的变换" class="headerlink" title="compose: 对 Observable 整体的变换"></a>compose: 对 Observable 整体的变换</h4><p>除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写：</p>
<pre><code>observable1
.lift1()
.lift2()
.lift3()
.lift4()
.subscribe(subscriber1);`

observable2
.lift1()
.lift2()
.lift3()
.lift4()
.subscribe(subscriber2);`

observable3
.lift1()
.lift2()
.lift3()
.lift4()
.subscribe(subscriber3);`

observable4
.lift1()
.lift2()
.lift3()
.lift4()
.subscribe(subscriber1);`
</code></pre><p>你觉得这样太不软件工程了，于是你改成了这样：</p>
<pre><code>private Observable liftAll(Observable observable) {
return observable
    .lift1()
    .lift2()
    .lift3()
    .lift4();
}
 ...
liftAll(observable1).subscribe(subscriber1);
liftAll(observable2).subscribe(subscriber2);
liftAll(observable3).subscribe(subscriber3);
liftAll(observable4).subscribe(subscriber4);`
</code></pre><p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了：</p>
<pre><code>public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; {
@Override
public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) {
    return observable
        .lift1()
        .lift2()
        .lift3()
        .lift4();
}
}
...
Transformer liftAll = new LiftAllTransformer();
observable1.compose(liftAll).subscribe(subscriber1);
observable2.compose(liftAll).subscribe(subscriber2);
observable3.compose(liftAll).subscribe(subscriber3);
observable4.compose(liftAll).subscribe(subscriber4);`
</code></pre><p>像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。</p>
<h4 id="线程控制：Scheduler-二"><a href="#线程控制：Scheduler-二" class="headerlink" title="线程控制：Scheduler (二)"></a>线程控制：Scheduler (二)</h4><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<p>1) Scheduler 的 API (二)</p>
<p>前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>
<p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码：</p>
<pre><code>`Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
.subscribeOn(Schedulers.io())
.observeOn(Schedulers.newThread())
.map(mapOperator) // 新线程，由 observeOn() 指定
.observeOn(Schedulers.io())
.map(mapOperator2) // IO 线程，由 observeOn() 指定
.observeOn(AndroidSchedulers.mainThread) 
.subscribe(subscriber);  // Android 主线程，由 observeOn() 指定`
</code></pre><p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。</p>
<p>不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。</p>
<h5 id="延伸：doOnSubscribe"><a href="#延伸：doOnSubscribe" class="headerlink" title="延伸：doOnSubscribe()"></a>延伸：doOnSubscribe()</h5><p>然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>
<p>在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：</p>
<pre><code>Observable.create(onSubscribe)
.subscribeOn(Schedulers.io())
.doOnSubscribe(new Action0() {
    @Override
    public void call() {
        progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行
    }
})
.subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程
.observeOn(AndroidSchedulers.mainThread())
.subscribe(subscriber);`
</code></pre><p>如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。</p>
<h2 id="RxJava-的适用场景和使用方式"><a href="#RxJava-的适用场景和使用方式" class="headerlink" title="RxJava 的适用场景和使用方式"></a>RxJava 的适用场景和使用方式</h2><h3 id="与-Retrofit-的结合"><a href="#与-Retrofit-的结合" class="headerlink" title="与 Retrofit 的结合"></a>与 Retrofit 的结合</h3><p>Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。</p>
<p>Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。</p>
<p>以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p>
<pre><code>`@GET(&quot;/user&quot;)
 public void getUser(@Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);`
</code></pre><p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p>
<pre><code>getUser(userId, new Callback&lt;User&gt;() {
@Override
public void success(User user) {
    userView.setUser(user);
}

@Override
public void failure(RetrofitError error) {
    // Error handling
    ...
}
 };
</code></pre><p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p>
<pre><code>`@GET(&quot;/user&quot;)
 public Observable&lt;User&gt; getUser(@Query(&quot;userId&quot;) String userId);`
</code></pre><p>使用的时候是这样的：</p>
<pre><code> getUser(userId)
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;User&gt;() {
    @Override
    public void onNext(User user) {
        userView.setUser(user);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable error) {
        // Error handling
        ...
    }
});`
</code></pre><p>看到区别了吗？</p>
<p>当 RxJava 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</p>
<p>对比来看， Callback 形式和 Observable 形式长得不太一样，但本质都差不多，而且在细节上 Observable 形式似乎还比 Callback 形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？</p>
<p>因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， Callback 形式马上就会开始让人头疼。比如：</p>
<p>假设这么一种情况：你的程序取到的 User 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 Callback 方式大概可以这么写：<br>    getUser(userId, new Callback<user>() {<br>    @Override<br>    public void success(User user) {<br>        processUser(user); // 尝试修正 User 数据<br>        userView.setUser(user);<br>    }</user></p>
<pre><code>@Override
public void failure(RetrofitError error) {
    // Error handling
    ...
}
};`
</code></pre><p>有问题吗？</p>
<p>很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下：</p>
<pre><code>getUser(userId, new Callback&lt;User&gt;() {
@Override
public void success(User user) {
    new Thread() {
        @Override
        public void run() {
            processUser(user); // 尝试修正 User 数据
            runOnUiThread(new Runnable() { // 切回 UI 线程
                @Override
                public void run() {
                    userView.setUser(user);
                }
            });
        }).start();
}

@Override
public void failure(RetrofitError error) {
    // Error handling
    ...
}
};`
</code></pre><p>性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。</p>
<p>这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的：</p>
<pre><code>getUser(userId)
.doOnNext(new Action1&lt;User&gt;() {
    @Override
    public void call(User user) {
        processUser(user);
    })
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;User&gt;() {
    @Override
    public void onNext(User user) {
        userView.setUser(user);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable error) {
        // Error handling
        ...
    }
});`
</code></pre><p>后台代码和前台代码全都写在一条链中，明显清晰了很多。</p>
<p>再举一个例子：假设 /user 接口并不能直接访问，而需要填入一个在线获取的 token ，代码应该怎么写？</p>
<p>Callback 方式，可以使用嵌套的 Callback：</p>
<pre><code> @GET(&quot;/token&quot;)
 public void getToken(Callback&lt;String&gt; callback);`

 @GET(&quot;/user&quot;)
 public void getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);

...

getToken(new Callback&lt;String&gt;() {
@Override
public void success(String token) {
    getUser(token, userId, new Callback&lt;User&gt;() {
        @Override
        public void success(User user) {
            userView.setUser(user);
        }

        @Override
        public void failure(RetrofitError error) {
            // Error handling
            ...
        }
    };
}

@Override
public void failure(RetrofitError error) {
    // Error handling
    ...
} 
});`
</code></pre><p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。</p>
<p>而使用 RxJava 的话，代码是这样的：</p>
<pre><code>`@GET(&quot;/token&quot;)
 public Observable&lt;String&gt; getToken();

 @GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId);

  ...

getToken()
.flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() {
    @Override
    public Observable&lt;User&gt; onNext(String token) {
        return getUser(token, userId);
    })
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer&lt;User&gt;() {
    @Override
    public void onNext(User user) {
        userView.setUser(user);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable error) {
        // Error handling
        ...
    }
});`
</code></pre><p>用一个 flatMap() 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p>
<h4 id="RxBinding"><a href="#RxBinding" class="headerlink" title="RxBinding"></a>RxBinding</h4><p>RxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。</p>
<p>举个设置点击监听的例子。使用 RxBinding ，可以把事件监听用这样的方法来设置：</p>
<pre><code>Button button = ...;
RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件
.subscribe(new Action1&lt;ViewClickEvent&gt;() {
    @Override
    public void call(ViewClickEvent event) {
        // Click handling
    }
});`
</code></pre><p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 setOnClickListener() 来实现的。然而，仅仅这一个形式的改变，却恰好就是 RxBinding 的目的：扩展性。通过 RxBinding 把点击监听转换成 Observable 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 throttleFirst() ，用于去抖动，也就是消除手抖导致的快速连环点击：</p>
<pre><code> RxView.clickEvents(button)
.throttleFirst(500, TimeUnit.MILLISECONDS)
.subscribe(clickAction);
</code></pre><p>如果想对 RxBinding 有更多了解，可以去它的 GitHub 项目 下面看看。</p>
<h6 id="各种异步操作"><a href="#各种异步操作" class="headerlink" title="各种异步操作"></a>各种异步操作</h6><p>前面举的 Retrofit 和 RxBinding 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/20/开源项目集锦/" rel="next" title="Crash信息收集并上传">
                <i class="fa fa-chevron-left"></i> Crash信息收集并上传
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/28/多渠道打包/" rel="prev" title="多渠道打包">
                多渠道打包 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="左文站" />
          <p class="site-author-name" itemprop="name">左文站</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJava-到底是什么"><span class="nav-number">1.</span> <span class="nav-text">RxJava 到底是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJava-好在哪"><span class="nav-number">2.</span> <span class="nav-text">RxJava 好在哪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举个例子"><span class="nav-number">3.</span> <span class="nav-text">举个例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJava-的观察者模式"><span class="nav-number"></span> <span class="nav-text">RxJava 的观察者模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本实现"><span class="nav-number"></span> <span class="nav-text">基本实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建-Observer"><span class="nav-number">1.</span> <span class="nav-text">创建 Observer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建-Observable"><span class="nav-number">2.</span> <span class="nav-text">创建 Observable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subscribe-订阅"><span class="nav-number">3.</span> <span class="nav-text">Subscribe (订阅)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#场景示例"><span class="nav-number"></span> <span class="nav-text">场景示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打印字符串数组"><span class="nav-number">1.</span> <span class="nav-text">打印字符串数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由-id-取得图片并显示"><span class="nav-number">2.</span> <span class="nav-text">由 id 取得图片并显示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制-——-Scheduler-一"><span class="nav-number"></span> <span class="nav-text">线程控制 —— Scheduler (一)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Scheduler-的-API-一"><span class="nav-number">1.</span> <span class="nav-text">1) Scheduler 的 API (一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scheduler-的原理-一"><span class="nav-number">2.</span> <span class="nav-text">Scheduler 的原理 (一)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变换"><span class="nav-number"></span> <span class="nav-text">变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#map-事件对象的直接变换，具体功能上面已经介绍过。它是-RxJava-最常用的变换。"><span class="nav-number">0.1.</span> <span class="nav-text">map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flatMap-这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。-首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单："><span class="nav-number">0.2.</span> <span class="nav-text">flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#throttleFirst-在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：-RxView-clickEvents-button-RxBinding-代码，后面的文章有解释-throttleFirst-500-TimeUnit-MILLISECONDS-设置防抖间隔为-500ms-subscribe-subscriber-妈妈再也不怕我的用户手抖点开两个重复的界面啦。"><span class="nav-number">0.3.</span> <span class="nav-text">throttleFirst(): 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变换的原理：lift"><span class="nav-number">1.</span> <span class="nav-text">变换的原理：lift()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#当含有-lift-时："><span class="nav-number">1.1.</span> <span class="nav-text">当含有 lift() 时：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#举一个具体的-Operator-的实现。下面这是一个将事件中的-Integer-对象转换成-String-的例子，仅供参考："><span class="nav-number">1.2.</span> <span class="nav-text">举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compose-对-Observable-整体的变换"><span class="nav-number">2.</span> <span class="nav-text">compose: 对 Observable 整体的变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程控制：Scheduler-二"><span class="nav-number">3.</span> <span class="nav-text">线程控制：Scheduler (二)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#延伸：doOnSubscribe"><span class="nav-number">3.1.</span> <span class="nav-text">延伸：doOnSubscribe()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RxJava-的适用场景和使用方式"><span class="nav-number"></span> <span class="nav-text">RxJava 的适用场景和使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与-Retrofit-的结合"><span class="nav-number"></span> <span class="nav-text">与 Retrofit 的结合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RxBinding"><span class="nav-number">1.</span> <span class="nav-text">RxBinding</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#各种异步操作"><span class="nav-number">1.0.1.</span> <span class="nav-text">各种异步操作</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">左文站</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "68b7fd0c14974964bb8bc7dbe7a34d69",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("vL8PNDBtyegKd6KMTvEeN7M5-gzGzoHsz", "kxEWPUUrnHF20Kij9gSNh82o");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
